// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package api

import (
	"context"
	"sync"
)

// Ensure, that ElasticSearcherMock does implement ElasticSearcher.
// If this is not the case, regenerate this file with moq.
var _ ElasticSearcher = &ElasticSearcherMock{}

// ElasticSearcherMock is a mock implementation of ElasticSearcher.
//
// 	func TestSomethingThatUsesElasticSearcher(t *testing.T) {
//
// 		// make and configure a mocked ElasticSearcher
// 		mockedElasticSearcher := &ElasticSearcherMock{
// 			CreateNewEmptyIndexFunc: func(ctx context.Context, indexName string) (bool, error) {
// 				panic("mock out the CreateNewEmptyIndex method")
// 			},
// 			GetStatusFunc: func(ctx context.Context) ([]byte, error) {
// 				panic("mock out the GetStatus method")
// 			},
// 			MultiSearchFunc: func(ctx context.Context, index string, docType string, request []byte) ([]byte, error) {
// 				panic("mock out the MultiSearch method")
// 			},
// 			SearchFunc: func(ctx context.Context, index string, docType string, request []byte) ([]byte, error) {
// 				panic("mock out the Search method")
// 			},
// 		}
//
// 		// use mockedElasticSearcher in code that requires ElasticSearcher
// 		// and then make assertions.
//
// 	}
type ElasticSearcherMock struct {
	// CreateNewEmptyIndexFunc mocks the CreateNewEmptyIndex method.
	CreateNewEmptyIndexFunc func(ctx context.Context, indexName string) (bool, error)

	// GetStatusFunc mocks the GetStatus method.
	GetStatusFunc func(ctx context.Context) ([]byte, error)

	// MultiSearchFunc mocks the MultiSearch method.
	MultiSearchFunc func(ctx context.Context, index string, docType string, request []byte) ([]byte, error)

	// SearchFunc mocks the Search method.
	SearchFunc func(ctx context.Context, index string, docType string, request []byte) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateNewEmptyIndex holds details about calls to the CreateNewEmptyIndex method.
		CreateNewEmptyIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IndexName is the indexName argument value.
			IndexName string
		}
		// GetStatus holds details about calls to the GetStatus method.
		GetStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// MultiSearch holds details about calls to the MultiSearch method.
		MultiSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// DocType is the docType argument value.
			DocType string
			// Request is the request argument value.
			Request []byte
		}
		// Search holds details about calls to the Search method.
		Search []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// DocType is the docType argument value.
			DocType string
			// Request is the request argument value.
			Request []byte
		}
	}
	lockCreateNewEmptyIndex sync.RWMutex
	lockGetStatus           sync.RWMutex
	lockMultiSearch         sync.RWMutex
	lockSearch              sync.RWMutex
}

// CreateNewEmptyIndex calls CreateNewEmptyIndexFunc.
func (mock *ElasticSearcherMock) CreateNewEmptyIndex(ctx context.Context, indexName string) (bool, error) {
	if mock.CreateNewEmptyIndexFunc == nil {
		panic("ElasticSearcherMock.CreateNewEmptyIndexFunc: method is nil but ElasticSearcher.CreateNewEmptyIndex was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		IndexName string
	}{
		Ctx:       ctx,
		IndexName: indexName,
	}
	mock.lockCreateNewEmptyIndex.Lock()
	mock.calls.CreateNewEmptyIndex = append(mock.calls.CreateNewEmptyIndex, callInfo)
	mock.lockCreateNewEmptyIndex.Unlock()
	return mock.CreateNewEmptyIndexFunc(ctx, indexName)
}

// CreateNewEmptyIndexCalls gets all the calls that were made to CreateNewEmptyIndex.
// Check the length with:
//     len(mockedElasticSearcher.CreateNewEmptyIndexCalls())
func (mock *ElasticSearcherMock) CreateNewEmptyIndexCalls() []struct {
	Ctx       context.Context
	IndexName string
} {
	var calls []struct {
		Ctx       context.Context
		IndexName string
	}
	mock.lockCreateNewEmptyIndex.RLock()
	calls = mock.calls.CreateNewEmptyIndex
	mock.lockCreateNewEmptyIndex.RUnlock()
	return calls
}

// GetStatus calls GetStatusFunc.
func (mock *ElasticSearcherMock) GetStatus(ctx context.Context) ([]byte, error) {
	if mock.GetStatusFunc == nil {
		panic("ElasticSearcherMock.GetStatusFunc: method is nil but ElasticSearcher.GetStatus was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetStatus.Lock()
	mock.calls.GetStatus = append(mock.calls.GetStatus, callInfo)
	mock.lockGetStatus.Unlock()
	return mock.GetStatusFunc(ctx)
}

// GetStatusCalls gets all the calls that were made to GetStatus.
// Check the length with:
//     len(mockedElasticSearcher.GetStatusCalls())
func (mock *ElasticSearcherMock) GetStatusCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetStatus.RLock()
	calls = mock.calls.GetStatus
	mock.lockGetStatus.RUnlock()
	return calls
}

// MultiSearch calls MultiSearchFunc.
func (mock *ElasticSearcherMock) MultiSearch(ctx context.Context, index string, docType string, request []byte) ([]byte, error) {
	if mock.MultiSearchFunc == nil {
		panic("ElasticSearcherMock.MultiSearchFunc: method is nil but ElasticSearcher.MultiSearch was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		DocType string
		Request []byte
	}{
		Ctx:     ctx,
		Index:   index,
		DocType: docType,
		Request: request,
	}
	mock.lockMultiSearch.Lock()
	mock.calls.MultiSearch = append(mock.calls.MultiSearch, callInfo)
	mock.lockMultiSearch.Unlock()
	return mock.MultiSearchFunc(ctx, index, docType, request)
}

// MultiSearchCalls gets all the calls that were made to MultiSearch.
// Check the length with:
//     len(mockedElasticSearcher.MultiSearchCalls())
func (mock *ElasticSearcherMock) MultiSearchCalls() []struct {
	Ctx     context.Context
	Index   string
	DocType string
	Request []byte
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		DocType string
		Request []byte
	}
	mock.lockMultiSearch.RLock()
	calls = mock.calls.MultiSearch
	mock.lockMultiSearch.RUnlock()
	return calls
}

// Search calls SearchFunc.
func (mock *ElasticSearcherMock) Search(ctx context.Context, index string, docType string, request []byte) ([]byte, error) {
	if mock.SearchFunc == nil {
		panic("ElasticSearcherMock.SearchFunc: method is nil but ElasticSearcher.Search was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		DocType string
		Request []byte
	}{
		Ctx:     ctx,
		Index:   index,
		DocType: docType,
		Request: request,
	}
	mock.lockSearch.Lock()
	mock.calls.Search = append(mock.calls.Search, callInfo)
	mock.lockSearch.Unlock()
	return mock.SearchFunc(ctx, index, docType, request)
}

// SearchCalls gets all the calls that were made to Search.
// Check the length with:
//     len(mockedElasticSearcher.SearchCalls())
func (mock *ElasticSearcherMock) SearchCalls() []struct {
	Ctx     context.Context
	Index   string
	DocType string
	Request []byte
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		DocType string
		Request []byte
	}
	mock.lockSearch.RLock()
	calls = mock.calls.Search
	mock.lockSearch.RUnlock()
	return calls
}

// Ensure, that QueryBuilderMock does implement QueryBuilder.
// If this is not the case, regenerate this file with moq.
var _ QueryBuilder = &QueryBuilderMock{}

// QueryBuilderMock is a mock implementation of QueryBuilder.
//
// 	func TestSomethingThatUsesQueryBuilder(t *testing.T) {
//
// 		// make and configure a mocked QueryBuilder
// 		mockedQueryBuilder := &QueryBuilderMock{
// 			BuildSearchQueryFunc: func(ctx context.Context, q string, contentTypes string, sort string, limit int, offset int) ([]byte, error) {
// 				panic("mock out the BuildSearchQuery method")
// 			},
// 		}
//
// 		// use mockedQueryBuilder in code that requires QueryBuilder
// 		// and then make assertions.
//
// 	}
type QueryBuilderMock struct {
	// BuildSearchQueryFunc mocks the BuildSearchQuery method.
	BuildSearchQueryFunc func(ctx context.Context, q string, contentTypes string, sort string, limit int, offset int) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// BuildSearchQuery holds details about calls to the BuildSearchQuery method.
		BuildSearchQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q string
			// ContentTypes is the contentTypes argument value.
			ContentTypes string
			// Sort is the sort argument value.
			Sort string
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
	}
	lockBuildSearchQuery sync.RWMutex
}

// BuildSearchQuery calls BuildSearchQueryFunc.
func (mock *QueryBuilderMock) BuildSearchQuery(ctx context.Context, q string, contentTypes string, sort string, limit int, offset int) ([]byte, error) {
	if mock.BuildSearchQueryFunc == nil {
		panic("QueryBuilderMock.BuildSearchQueryFunc: method is nil but QueryBuilder.BuildSearchQuery was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Q            string
		ContentTypes string
		Sort         string
		Limit        int
		Offset       int
	}{
		Ctx:          ctx,
		Q:            q,
		ContentTypes: contentTypes,
		Sort:         sort,
		Limit:        limit,
		Offset:       offset,
	}
	mock.lockBuildSearchQuery.Lock()
	mock.calls.BuildSearchQuery = append(mock.calls.BuildSearchQuery, callInfo)
	mock.lockBuildSearchQuery.Unlock()
	return mock.BuildSearchQueryFunc(ctx, q, contentTypes, sort, limit, offset)
}

// BuildSearchQueryCalls gets all the calls that were made to BuildSearchQuery.
// Check the length with:
//     len(mockedQueryBuilder.BuildSearchQueryCalls())
func (mock *QueryBuilderMock) BuildSearchQueryCalls() []struct {
	Ctx          context.Context
	Q            string
	ContentTypes string
	Sort         string
	Limit        int
	Offset       int
} {
	var calls []struct {
		Ctx          context.Context
		Q            string
		ContentTypes string
		Sort         string
		Limit        int
		Offset       int
	}
	mock.lockBuildSearchQuery.RLock()
	calls = mock.calls.BuildSearchQuery
	mock.lockBuildSearchQuery.RUnlock()
	return calls
}

// Ensure, that ResponseTransformerMock does implement ResponseTransformer.
// If this is not the case, regenerate this file with moq.
var _ ResponseTransformer = &ResponseTransformerMock{}

// ResponseTransformerMock is a mock implementation of ResponseTransformer.
//
// 	func TestSomethingThatUsesResponseTransformer(t *testing.T) {
//
// 		// make and configure a mocked ResponseTransformer
// 		mockedResponseTransformer := &ResponseTransformerMock{
// 			TransformSearchResponseFunc: func(ctx context.Context, responseData []byte, query string, highlight bool) ([]byte, error) {
// 				panic("mock out the TransformSearchResponse method")
// 			},
// 		}
//
// 		// use mockedResponseTransformer in code that requires ResponseTransformer
// 		// and then make assertions.
//
// 	}
type ResponseTransformerMock struct {
	// TransformSearchResponseFunc mocks the TransformSearchResponse method.
	TransformSearchResponseFunc func(ctx context.Context, responseData []byte, query string, highlight bool) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// TransformSearchResponse holds details about calls to the TransformSearchResponse method.
		TransformSearchResponse []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ResponseData is the responseData argument value.
			ResponseData []byte
			// Query is the query argument value.
			Query string
			// Highlight is the highlight argument value.
			Highlight bool
		}
	}
	lockTransformSearchResponse sync.RWMutex
}

// TransformSearchResponse calls TransformSearchResponseFunc.
func (mock *ResponseTransformerMock) TransformSearchResponse(ctx context.Context, responseData []byte, query string, highlight bool) ([]byte, error) {
	if mock.TransformSearchResponseFunc == nil {
		panic("ResponseTransformerMock.TransformSearchResponseFunc: method is nil but ResponseTransformer.TransformSearchResponse was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		ResponseData []byte
		Query        string
		Highlight    bool
	}{
		Ctx:          ctx,
		ResponseData: responseData,
		Query:        query,
		Highlight:    highlight,
	}
	mock.lockTransformSearchResponse.Lock()
	mock.calls.TransformSearchResponse = append(mock.calls.TransformSearchResponse, callInfo)
	mock.lockTransformSearchResponse.Unlock()
	return mock.TransformSearchResponseFunc(ctx, responseData, query, highlight)
}

// TransformSearchResponseCalls gets all the calls that were made to TransformSearchResponse.
// Check the length with:
//     len(mockedResponseTransformer.TransformSearchResponseCalls())
func (mock *ResponseTransformerMock) TransformSearchResponseCalls() []struct {
	Ctx          context.Context
	ResponseData []byte
	Query        string
	Highlight    bool
} {
	var calls []struct {
		Ctx          context.Context
		ResponseData []byte
		Query        string
		Highlight    bool
	}
	mock.lockTransformSearchResponse.RLock()
	calls = mock.calls.TransformSearchResponse
	mock.lockTransformSearchResponse.RUnlock()
	return calls
}
